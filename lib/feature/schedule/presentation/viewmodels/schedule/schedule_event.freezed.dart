// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schedule_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$ScheduleEvent {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ScheduleEvent);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent()';
}


}

/// @nodoc
class $ScheduleEventCopyWith<$Res>  {
$ScheduleEventCopyWith(ScheduleEvent _, $Res Function(ScheduleEvent) __);
}


/// Adds pattern-matching-related methods to [ScheduleEvent].
extension ScheduleEventPatterns on ScheduleEvent {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( FetchSchedules value)?  fetchSchedules,TResult Function( SelectDate value)?  selectDate,TResult Function( SelectCategory value)?  selectCategory,TResult Function( ClearFilter value)?  clearFilter,TResult Function( NavigateToCreate value)?  navigateToCreate,TResult Function( DeleteSchedule value)?  deleteSchedule,TResult Function( NavigateToEdit value)?  navigateToEdit,TResult Function( FetchScheduleMembers value)?  fetchScheduleMembers,TResult Function( Refresh value)?  refresh,TResult Function( ToggleMemo value)?  toggleMemo,TResult Function( SwitchToDateMode value)?  switchToDateMode,TResult Function( SwitchToCategoryMode value)?  switchToCategoryMode,TResult Function( LoadMore value)?  loadMore,TResult Function( ResetNavigation value)?  resetNavigation,TResult Function( ClearMessage value)?  clearMessage,required TResult orElse(),}){
final _that = this;
switch (_that) {
case FetchSchedules() when fetchSchedules != null:
return fetchSchedules(_that);case SelectDate() when selectDate != null:
return selectDate(_that);case SelectCategory() when selectCategory != null:
return selectCategory(_that);case ClearFilter() when clearFilter != null:
return clearFilter(_that);case NavigateToCreate() when navigateToCreate != null:
return navigateToCreate(_that);case DeleteSchedule() when deleteSchedule != null:
return deleteSchedule(_that);case NavigateToEdit() when navigateToEdit != null:
return navigateToEdit(_that);case FetchScheduleMembers() when fetchScheduleMembers != null:
return fetchScheduleMembers(_that);case Refresh() when refresh != null:
return refresh(_that);case ToggleMemo() when toggleMemo != null:
return toggleMemo(_that);case SwitchToDateMode() when switchToDateMode != null:
return switchToDateMode(_that);case SwitchToCategoryMode() when switchToCategoryMode != null:
return switchToCategoryMode(_that);case LoadMore() when loadMore != null:
return loadMore(_that);case ResetNavigation() when resetNavigation != null:
return resetNavigation(_that);case ClearMessage() when clearMessage != null:
return clearMessage(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( FetchSchedules value)  fetchSchedules,required TResult Function( SelectDate value)  selectDate,required TResult Function( SelectCategory value)  selectCategory,required TResult Function( ClearFilter value)  clearFilter,required TResult Function( NavigateToCreate value)  navigateToCreate,required TResult Function( DeleteSchedule value)  deleteSchedule,required TResult Function( NavigateToEdit value)  navigateToEdit,required TResult Function( FetchScheduleMembers value)  fetchScheduleMembers,required TResult Function( Refresh value)  refresh,required TResult Function( ToggleMemo value)  toggleMemo,required TResult Function( SwitchToDateMode value)  switchToDateMode,required TResult Function( SwitchToCategoryMode value)  switchToCategoryMode,required TResult Function( LoadMore value)  loadMore,required TResult Function( ResetNavigation value)  resetNavigation,required TResult Function( ClearMessage value)  clearMessage,}){
final _that = this;
switch (_that) {
case FetchSchedules():
return fetchSchedules(_that);case SelectDate():
return selectDate(_that);case SelectCategory():
return selectCategory(_that);case ClearFilter():
return clearFilter(_that);case NavigateToCreate():
return navigateToCreate(_that);case DeleteSchedule():
return deleteSchedule(_that);case NavigateToEdit():
return navigateToEdit(_that);case FetchScheduleMembers():
return fetchScheduleMembers(_that);case Refresh():
return refresh(_that);case ToggleMemo():
return toggleMemo(_that);case SwitchToDateMode():
return switchToDateMode(_that);case SwitchToCategoryMode():
return switchToCategoryMode(_that);case LoadMore():
return loadMore(_that);case ResetNavigation():
return resetNavigation(_that);case ClearMessage():
return clearMessage(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( FetchSchedules value)?  fetchSchedules,TResult? Function( SelectDate value)?  selectDate,TResult? Function( SelectCategory value)?  selectCategory,TResult? Function( ClearFilter value)?  clearFilter,TResult? Function( NavigateToCreate value)?  navigateToCreate,TResult? Function( DeleteSchedule value)?  deleteSchedule,TResult? Function( NavigateToEdit value)?  navigateToEdit,TResult? Function( FetchScheduleMembers value)?  fetchScheduleMembers,TResult? Function( Refresh value)?  refresh,TResult? Function( ToggleMemo value)?  toggleMemo,TResult? Function( SwitchToDateMode value)?  switchToDateMode,TResult? Function( SwitchToCategoryMode value)?  switchToCategoryMode,TResult? Function( LoadMore value)?  loadMore,TResult? Function( ResetNavigation value)?  resetNavigation,TResult? Function( ClearMessage value)?  clearMessage,}){
final _that = this;
switch (_that) {
case FetchSchedules() when fetchSchedules != null:
return fetchSchedules(_that);case SelectDate() when selectDate != null:
return selectDate(_that);case SelectCategory() when selectCategory != null:
return selectCategory(_that);case ClearFilter() when clearFilter != null:
return clearFilter(_that);case NavigateToCreate() when navigateToCreate != null:
return navigateToCreate(_that);case DeleteSchedule() when deleteSchedule != null:
return deleteSchedule(_that);case NavigateToEdit() when navigateToEdit != null:
return navigateToEdit(_that);case FetchScheduleMembers() when fetchScheduleMembers != null:
return fetchScheduleMembers(_that);case Refresh() when refresh != null:
return refresh(_that);case ToggleMemo() when toggleMemo != null:
return toggleMemo(_that);case SwitchToDateMode() when switchToDateMode != null:
return switchToDateMode(_that);case SwitchToCategoryMode() when switchToCategoryMode != null:
return switchToCategoryMode(_that);case LoadMore() when loadMore != null:
return loadMore(_that);case ResetNavigation() when resetNavigation != null:
return resetNavigation(_that);case ClearMessage() when clearMessage != null:
return clearMessage(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( int tripId,  bool isRefresh)?  fetchSchedules,TResult Function( String date)?  selectDate,TResult Function( int categoryId)?  selectCategory,TResult Function()?  clearFilter,TResult Function()?  navigateToCreate,TResult Function( int scheduleId)?  deleteSchedule,TResult Function( ScheduleEntity schedule)?  navigateToEdit,TResult Function( int scheduleId)?  fetchScheduleMembers,TResult Function( int tripId)?  refresh,TResult Function()?  toggleMemo,TResult Function()?  switchToDateMode,TResult Function()?  switchToCategoryMode,TResult Function( int tripId)?  loadMore,TResult Function()?  resetNavigation,TResult Function()?  clearMessage,required TResult orElse(),}) {final _that = this;
switch (_that) {
case FetchSchedules() when fetchSchedules != null:
return fetchSchedules(_that.tripId,_that.isRefresh);case SelectDate() when selectDate != null:
return selectDate(_that.date);case SelectCategory() when selectCategory != null:
return selectCategory(_that.categoryId);case ClearFilter() when clearFilter != null:
return clearFilter();case NavigateToCreate() when navigateToCreate != null:
return navigateToCreate();case DeleteSchedule() when deleteSchedule != null:
return deleteSchedule(_that.scheduleId);case NavigateToEdit() when navigateToEdit != null:
return navigateToEdit(_that.schedule);case FetchScheduleMembers() when fetchScheduleMembers != null:
return fetchScheduleMembers(_that.scheduleId);case Refresh() when refresh != null:
return refresh(_that.tripId);case ToggleMemo() when toggleMemo != null:
return toggleMemo();case SwitchToDateMode() when switchToDateMode != null:
return switchToDateMode();case SwitchToCategoryMode() when switchToCategoryMode != null:
return switchToCategoryMode();case LoadMore() when loadMore != null:
return loadMore(_that.tripId);case ResetNavigation() when resetNavigation != null:
return resetNavigation();case ClearMessage() when clearMessage != null:
return clearMessage();case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( int tripId,  bool isRefresh)  fetchSchedules,required TResult Function( String date)  selectDate,required TResult Function( int categoryId)  selectCategory,required TResult Function()  clearFilter,required TResult Function()  navigateToCreate,required TResult Function( int scheduleId)  deleteSchedule,required TResult Function( ScheduleEntity schedule)  navigateToEdit,required TResult Function( int scheduleId)  fetchScheduleMembers,required TResult Function( int tripId)  refresh,required TResult Function()  toggleMemo,required TResult Function()  switchToDateMode,required TResult Function()  switchToCategoryMode,required TResult Function( int tripId)  loadMore,required TResult Function()  resetNavigation,required TResult Function()  clearMessage,}) {final _that = this;
switch (_that) {
case FetchSchedules():
return fetchSchedules(_that.tripId,_that.isRefresh);case SelectDate():
return selectDate(_that.date);case SelectCategory():
return selectCategory(_that.categoryId);case ClearFilter():
return clearFilter();case NavigateToCreate():
return navigateToCreate();case DeleteSchedule():
return deleteSchedule(_that.scheduleId);case NavigateToEdit():
return navigateToEdit(_that.schedule);case FetchScheduleMembers():
return fetchScheduleMembers(_that.scheduleId);case Refresh():
return refresh(_that.tripId);case ToggleMemo():
return toggleMemo();case SwitchToDateMode():
return switchToDateMode();case SwitchToCategoryMode():
return switchToCategoryMode();case LoadMore():
return loadMore(_that.tripId);case ResetNavigation():
return resetNavigation();case ClearMessage():
return clearMessage();case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( int tripId,  bool isRefresh)?  fetchSchedules,TResult? Function( String date)?  selectDate,TResult? Function( int categoryId)?  selectCategory,TResult? Function()?  clearFilter,TResult? Function()?  navigateToCreate,TResult? Function( int scheduleId)?  deleteSchedule,TResult? Function( ScheduleEntity schedule)?  navigateToEdit,TResult? Function( int scheduleId)?  fetchScheduleMembers,TResult? Function( int tripId)?  refresh,TResult? Function()?  toggleMemo,TResult? Function()?  switchToDateMode,TResult? Function()?  switchToCategoryMode,TResult? Function( int tripId)?  loadMore,TResult? Function()?  resetNavigation,TResult? Function()?  clearMessage,}) {final _that = this;
switch (_that) {
case FetchSchedules() when fetchSchedules != null:
return fetchSchedules(_that.tripId,_that.isRefresh);case SelectDate() when selectDate != null:
return selectDate(_that.date);case SelectCategory() when selectCategory != null:
return selectCategory(_that.categoryId);case ClearFilter() when clearFilter != null:
return clearFilter();case NavigateToCreate() when navigateToCreate != null:
return navigateToCreate();case DeleteSchedule() when deleteSchedule != null:
return deleteSchedule(_that.scheduleId);case NavigateToEdit() when navigateToEdit != null:
return navigateToEdit(_that.schedule);case FetchScheduleMembers() when fetchScheduleMembers != null:
return fetchScheduleMembers(_that.scheduleId);case Refresh() when refresh != null:
return refresh(_that.tripId);case ToggleMemo() when toggleMemo != null:
return toggleMemo();case SwitchToDateMode() when switchToDateMode != null:
return switchToDateMode();case SwitchToCategoryMode() when switchToCategoryMode != null:
return switchToCategoryMode();case LoadMore() when loadMore != null:
return loadMore(_that.tripId);case ResetNavigation() when resetNavigation != null:
return resetNavigation();case ClearMessage() when clearMessage != null:
return clearMessage();case _:
  return null;

}
}

}

/// @nodoc


class FetchSchedules implements ScheduleEvent {
  const FetchSchedules({required this.tripId, this.isRefresh = false});
  

 final  int tripId;
@JsonKey() final  bool isRefresh;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FetchSchedulesCopyWith<FetchSchedules> get copyWith => _$FetchSchedulesCopyWithImpl<FetchSchedules>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FetchSchedules&&(identical(other.tripId, tripId) || other.tripId == tripId)&&(identical(other.isRefresh, isRefresh) || other.isRefresh == isRefresh));
}


@override
int get hashCode => Object.hash(runtimeType,tripId,isRefresh);

@override
String toString() {
  return 'ScheduleEvent.fetchSchedules(tripId: $tripId, isRefresh: $isRefresh)';
}


}

/// @nodoc
abstract mixin class $FetchSchedulesCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $FetchSchedulesCopyWith(FetchSchedules value, $Res Function(FetchSchedules) _then) = _$FetchSchedulesCopyWithImpl;
@useResult
$Res call({
 int tripId, bool isRefresh
});




}
/// @nodoc
class _$FetchSchedulesCopyWithImpl<$Res>
    implements $FetchSchedulesCopyWith<$Res> {
  _$FetchSchedulesCopyWithImpl(this._self, this._then);

  final FetchSchedules _self;
  final $Res Function(FetchSchedules) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tripId = null,Object? isRefresh = null,}) {
  return _then(FetchSchedules(
tripId: null == tripId ? _self.tripId : tripId // ignore: cast_nullable_to_non_nullable
as int,isRefresh: null == isRefresh ? _self.isRefresh : isRefresh // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc


class SelectDate implements ScheduleEvent {
  const SelectDate({required this.date});
  

 final  String date;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectDateCopyWith<SelectDate> get copyWith => _$SelectDateCopyWithImpl<SelectDate>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectDate&&(identical(other.date, date) || other.date == date));
}


@override
int get hashCode => Object.hash(runtimeType,date);

@override
String toString() {
  return 'ScheduleEvent.selectDate(date: $date)';
}


}

/// @nodoc
abstract mixin class $SelectDateCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $SelectDateCopyWith(SelectDate value, $Res Function(SelectDate) _then) = _$SelectDateCopyWithImpl;
@useResult
$Res call({
 String date
});




}
/// @nodoc
class _$SelectDateCopyWithImpl<$Res>
    implements $SelectDateCopyWith<$Res> {
  _$SelectDateCopyWithImpl(this._self, this._then);

  final SelectDate _self;
  final $Res Function(SelectDate) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? date = null,}) {
  return _then(SelectDate(
date: null == date ? _self.date : date // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class SelectCategory implements ScheduleEvent {
  const SelectCategory({required this.categoryId});
  

 final  int categoryId;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectCategoryCopyWith<SelectCategory> get copyWith => _$SelectCategoryCopyWithImpl<SelectCategory>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectCategory&&(identical(other.categoryId, categoryId) || other.categoryId == categoryId));
}


@override
int get hashCode => Object.hash(runtimeType,categoryId);

@override
String toString() {
  return 'ScheduleEvent.selectCategory(categoryId: $categoryId)';
}


}

/// @nodoc
abstract mixin class $SelectCategoryCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $SelectCategoryCopyWith(SelectCategory value, $Res Function(SelectCategory) _then) = _$SelectCategoryCopyWithImpl;
@useResult
$Res call({
 int categoryId
});




}
/// @nodoc
class _$SelectCategoryCopyWithImpl<$Res>
    implements $SelectCategoryCopyWith<$Res> {
  _$SelectCategoryCopyWithImpl(this._self, this._then);

  final SelectCategory _self;
  final $Res Function(SelectCategory) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? categoryId = null,}) {
  return _then(SelectCategory(
categoryId: null == categoryId ? _self.categoryId : categoryId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class ClearFilter implements ScheduleEvent {
  const ClearFilter();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ClearFilter);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent.clearFilter()';
}


}




/// @nodoc


class NavigateToCreate implements ScheduleEvent {
  const NavigateToCreate();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NavigateToCreate);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent.navigateToCreate()';
}


}




/// @nodoc


class DeleteSchedule implements ScheduleEvent {
  const DeleteSchedule(this.scheduleId);
  

 final  int scheduleId;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeleteScheduleCopyWith<DeleteSchedule> get copyWith => _$DeleteScheduleCopyWithImpl<DeleteSchedule>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteSchedule&&(identical(other.scheduleId, scheduleId) || other.scheduleId == scheduleId));
}


@override
int get hashCode => Object.hash(runtimeType,scheduleId);

@override
String toString() {
  return 'ScheduleEvent.deleteSchedule(scheduleId: $scheduleId)';
}


}

/// @nodoc
abstract mixin class $DeleteScheduleCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $DeleteScheduleCopyWith(DeleteSchedule value, $Res Function(DeleteSchedule) _then) = _$DeleteScheduleCopyWithImpl;
@useResult
$Res call({
 int scheduleId
});




}
/// @nodoc
class _$DeleteScheduleCopyWithImpl<$Res>
    implements $DeleteScheduleCopyWith<$Res> {
  _$DeleteScheduleCopyWithImpl(this._self, this._then);

  final DeleteSchedule _self;
  final $Res Function(DeleteSchedule) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? scheduleId = null,}) {
  return _then(DeleteSchedule(
null == scheduleId ? _self.scheduleId : scheduleId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class NavigateToEdit implements ScheduleEvent {
  const NavigateToEdit({required this.schedule});
  

 final  ScheduleEntity schedule;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NavigateToEditCopyWith<NavigateToEdit> get copyWith => _$NavigateToEditCopyWithImpl<NavigateToEdit>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NavigateToEdit&&(identical(other.schedule, schedule) || other.schedule == schedule));
}


@override
int get hashCode => Object.hash(runtimeType,schedule);

@override
String toString() {
  return 'ScheduleEvent.navigateToEdit(schedule: $schedule)';
}


}

/// @nodoc
abstract mixin class $NavigateToEditCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $NavigateToEditCopyWith(NavigateToEdit value, $Res Function(NavigateToEdit) _then) = _$NavigateToEditCopyWithImpl;
@useResult
$Res call({
 ScheduleEntity schedule
});


$ScheduleEntityCopyWith<$Res> get schedule;

}
/// @nodoc
class _$NavigateToEditCopyWithImpl<$Res>
    implements $NavigateToEditCopyWith<$Res> {
  _$NavigateToEditCopyWithImpl(this._self, this._then);

  final NavigateToEdit _self;
  final $Res Function(NavigateToEdit) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? schedule = null,}) {
  return _then(NavigateToEdit(
schedule: null == schedule ? _self.schedule : schedule // ignore: cast_nullable_to_non_nullable
as ScheduleEntity,
  ));
}

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ScheduleEntityCopyWith<$Res> get schedule {
  
  return $ScheduleEntityCopyWith<$Res>(_self.schedule, (value) {
    return _then(_self.copyWith(schedule: value));
  });
}
}

/// @nodoc


class FetchScheduleMembers implements ScheduleEvent {
  const FetchScheduleMembers({required this.scheduleId});
  

 final  int scheduleId;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FetchScheduleMembersCopyWith<FetchScheduleMembers> get copyWith => _$FetchScheduleMembersCopyWithImpl<FetchScheduleMembers>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FetchScheduleMembers&&(identical(other.scheduleId, scheduleId) || other.scheduleId == scheduleId));
}


@override
int get hashCode => Object.hash(runtimeType,scheduleId);

@override
String toString() {
  return 'ScheduleEvent.fetchScheduleMembers(scheduleId: $scheduleId)';
}


}

/// @nodoc
abstract mixin class $FetchScheduleMembersCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $FetchScheduleMembersCopyWith(FetchScheduleMembers value, $Res Function(FetchScheduleMembers) _then) = _$FetchScheduleMembersCopyWithImpl;
@useResult
$Res call({
 int scheduleId
});




}
/// @nodoc
class _$FetchScheduleMembersCopyWithImpl<$Res>
    implements $FetchScheduleMembersCopyWith<$Res> {
  _$FetchScheduleMembersCopyWithImpl(this._self, this._then);

  final FetchScheduleMembers _self;
  final $Res Function(FetchScheduleMembers) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? scheduleId = null,}) {
  return _then(FetchScheduleMembers(
scheduleId: null == scheduleId ? _self.scheduleId : scheduleId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class Refresh implements ScheduleEvent {
  const Refresh({required this.tripId});
  

 final  int tripId;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RefreshCopyWith<Refresh> get copyWith => _$RefreshCopyWithImpl<Refresh>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Refresh&&(identical(other.tripId, tripId) || other.tripId == tripId));
}


@override
int get hashCode => Object.hash(runtimeType,tripId);

@override
String toString() {
  return 'ScheduleEvent.refresh(tripId: $tripId)';
}


}

/// @nodoc
abstract mixin class $RefreshCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $RefreshCopyWith(Refresh value, $Res Function(Refresh) _then) = _$RefreshCopyWithImpl;
@useResult
$Res call({
 int tripId
});




}
/// @nodoc
class _$RefreshCopyWithImpl<$Res>
    implements $RefreshCopyWith<$Res> {
  _$RefreshCopyWithImpl(this._self, this._then);

  final Refresh _self;
  final $Res Function(Refresh) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tripId = null,}) {
  return _then(Refresh(
tripId: null == tripId ? _self.tripId : tripId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class ToggleMemo implements ScheduleEvent {
  const ToggleMemo();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ToggleMemo);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent.toggleMemo()';
}


}




/// @nodoc


class SwitchToDateMode implements ScheduleEvent {
  const SwitchToDateMode();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SwitchToDateMode);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent.switchToDateMode()';
}


}




/// @nodoc


class SwitchToCategoryMode implements ScheduleEvent {
  const SwitchToCategoryMode();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SwitchToCategoryMode);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent.switchToCategoryMode()';
}


}




/// @nodoc


class LoadMore implements ScheduleEvent {
  const LoadMore({required this.tripId});
  

 final  int tripId;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LoadMoreCopyWith<LoadMore> get copyWith => _$LoadMoreCopyWithImpl<LoadMore>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoadMore&&(identical(other.tripId, tripId) || other.tripId == tripId));
}


@override
int get hashCode => Object.hash(runtimeType,tripId);

@override
String toString() {
  return 'ScheduleEvent.loadMore(tripId: $tripId)';
}


}

/// @nodoc
abstract mixin class $LoadMoreCopyWith<$Res> implements $ScheduleEventCopyWith<$Res> {
  factory $LoadMoreCopyWith(LoadMore value, $Res Function(LoadMore) _then) = _$LoadMoreCopyWithImpl;
@useResult
$Res call({
 int tripId
});




}
/// @nodoc
class _$LoadMoreCopyWithImpl<$Res>
    implements $LoadMoreCopyWith<$Res> {
  _$LoadMoreCopyWithImpl(this._self, this._then);

  final LoadMore _self;
  final $Res Function(LoadMore) _then;

/// Create a copy of ScheduleEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tripId = null,}) {
  return _then(LoadMore(
tripId: null == tripId ? _self.tripId : tripId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class ResetNavigation implements ScheduleEvent {
  const ResetNavigation();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ResetNavigation);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent.resetNavigation()';
}


}




/// @nodoc


class ClearMessage implements ScheduleEvent {
  const ClearMessage();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ClearMessage);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ScheduleEvent.clearMessage()';
}


}




// dart format on
